# Phaser examples

Phaser типът разпаралеляване на обработката и синхронизацията на паралелните нишки ни дава възможност да синхронизираме
паралелни нишки в определени моменти от екзекуцията на процеса, наречени фази. Краят на всяка фаза действа като бариера,
която блокира основната нишка и изчаква всички нишки от нея да приключат, за да отблокира главната нишка и процесът да
продължи, евентуално разпаралелявайки се пак в отделни нишки, които трябва да се синхронизират на следваш етап (фаза).   

### Съдържание
Пакетът съдържа една версия на програма за симулация на бързината на реакцията на различни хора, които реагират на
даден стимул. Най-бавно реагиралият човек отпада от списъка, докато не остане само един.
Визуално, процесът на програмата-пример може да бъде репрезентиран по следния начин:
<img src="http://e-mo.org/university/phaser.png" />
```aidl
bg.tu.pp.phasers (пакетът с кода, свързан с barrier примерите)
|
+ - dto (Data Transfer Object package)
|   |
|   + - Player.java (обект за репрезентация на участник);
|
+ - logic (съдържа логиката, нужна за симулация на мисловна дейност)
|   |
|   + - BogusBusinessLogic.java (клас, симулиращ обработка на данни, отнемащ различно време)
|
+ - main (съдържа главният клас на програмата, както и класът, който е нужно да бъде инстанциран, за да работи правилно програмата)
|   |
|   + - FastestReactionPhaserExample.java (entry point на програмата)
|   |
|   + - PhaserRunner.java (инстанцията, към която главната нишка се прикрепя, съдържа основната логика)
|
+ - threads (съдържа имплементатията на нишките, в този случай - само една)
    |
    + - ReactionThread.java (клас, използван за инстанциите на паралелните нишки; използва BogusBusinessLogic)
```

### Бележки
По време на упражнението се сблъскахме с проблем, при който синхронизацията не работеше по очакваният от нас начин.
Нишките не се синхронизираха и главната нишка не се блокираше. При по-задълбочен анализ offline, успяхме да открием, че
проблемът се състоеше от 2 под-проблема:
1. Няма как да регистрираме тред във фазера, когато се намираме в статичен метод и няма инстанция, която той да
регистрира. Наложи се да направим нов клас, който да съдържа бизнес логиката, която бяхме сложили в **main()** метода,
да създадем негова инстанция във въпросния мейн метод, да регистрираме към фазера текущия тред, асоциран с точно тази
инстанция, за да имаме основа, върху която фазера да се закотви. Би било добре **register()** методът на фазера да
хвърля ексепшън, когато не може да установи парънт инстанцията, но поради някаква причина логиката му не е написана така.
<br />**Извод:** Тредовете се асоцират с инстанциите на класовете (обектите), които изпълняват командния ред
**phaser.register();** Следете текущия стактрейс, за да е ясно къде точно се намира екзекуцията в йерархията от
инстанции и дали наистина има такива, както в нашия случай се наложи да проверя и се оказа, че няма.
2. В метода **ReactionThread.run()** според примерите, които наблюдавахме, първият ред е
**phaser.arriveAndAwaitAdvance()** според самите примери. Този метод би следвало да блокира текущия тред, докато
останалите се изпълнят и е леко шизофренично да го има, тъй като ние разпаралеляваме екзекуцията, за да не чакаме.
В момента, в който беше премахнат този команден ред, фазерът започна да се държи както се очакваше.
<br />**Извод:** Не се осланяйте на всеки пример в интернет, особено в stack overflow и подобните. Винаги проверявайте
дали примерите, които са представени там наистина работят и дали са приложими във вашия случай.
